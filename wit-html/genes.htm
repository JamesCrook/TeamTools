<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Demo Page</title>
    <style type="text/css">
        h1 {
            font-size: 2em;
        }

        h2 {
            font-size: 1.5em;
        }

        h3 {
            font-size: 1.17em;
        }

        td > h3 {
            margin-block-start: 0px;
            margin-block-end: 0px;
        }

        td > h2 {
            margin-block-start: 0px;
            margin-block-end: 0px;
        }

        td > h1 {
            margin-block-start: 0px;
            margin-block-end: 0px;
        }

        h4 {
            font-size: 1.12em;
        }

        h5 {
            font-size: .83em;
        }

        h6 {
            font-size: .67em;
        }

        html * {
            font-family: Arial;
        }

        textarea {
            font-family:Lucida Console,monospace;
        }

        #logoback {
            transition: all 0.15s;
            background-color: #edebfc;
            border: 2px solid;
            border-color: #edebfc;
            position: absolute;
            top: 1.25em;
            left: 0.9375em;
            width: 5.75em;
            height: 5.75em;
            color: black;
            box-sizing: border-box;
            line-height: 5.75em;
            border-radius: 2.875em;
            box-shadow: 0px 0px 1.25em 1px #000080;
        }

        #logoback:hover {
            /*background-color: #c7cfff;*/
            border-color: #848ff8;
        }

        #logo {
            position: relative;
            top: 0.5em;
            left: 0.5625em;
            transition: all 0.1s;
            width: 4.375em;
            height: 4.375em;

        }

        #logo:hover {
            /*top:6px;*/
            /*transform: rotate(10deg);*/
        }

        #logo:hover:active {
            width: 5em;
            height: 5em;
            left: 0.25em;
            top: 0.0625em;
        }

        pre {
            background-color: #1d2134;
            color: yellow;
        }

        div.bt {

            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;

            display: inline-block;
            color: black;
            font-size: 13px;
            border: 1px solid;
            padding: 2px 15px 2px 15px;
            border-color: #8696b2;
            background-color: #c5d4fc;
            box-shadow: inset 0 -5px 5px 0 #a6c1e7;
        }

        div.bt:hover {
            cursor: pointer;
            /*box-shadow: inset 0 -5px 15px 0 #7c94b7;*/
            background-color: #a9bdff;
            border-color: #2130ba;
        }

        div.bt:hover:active {
            background-color: #a5c3ee;
            box-shadow: inset 0 2px 5px 0 #7c94b7;
        }


        img.centred {
            position: absolute;
            top: -9999px;
            left: -9999px;
            bottom: -9999px;
            right: -9999px;
            margin: auto;
        }


        div.linky:hover {
            /* background-color: #a5c3ee;*/
            border-color: #848ff8;

        }

        div.pos-resetter {
            width: 100%;
            display: inline-block;
            text-align: center;
            position: absolute;
            margin: 0 auto;
        }

        div.linky {
            transition: all 0.15s;
            display: none;
            background-color: #c5d4fc;
            border: 2px solid;
            border-color: #c5d4fc;
            /*border-color: #8696b2;*/
            padding: 0px 1.25em 0px 1.25em;
            color: black;
            height: 2.25em;
            line-height: 2.25em;
            box-sizing: border-box;
            border-radius: 1.25em;
            margin: 0 auto;
            box-shadow: 0 0 20px 1px #000080;
            cursor: pointer;

        }
    </style>
    <script>
      console.log("Protocol is " + window.location.protocol);
      if( window.location.protocol === "http:" ){
        console.log("Http: detected");
        if( window.location.href.indexOf("localhost") <
          0 ) window.location.href = "https:" + window.location.href.slice(5);
      }
</script>
    <script>

        // Put everything into the object A.  Later that means we can
        // have more than one collection.
        var A={};
        function rand(n){
          return Math.floor(Math.random() * n);
        }

        // https://stackoverflow.com/questions/1431094/
        String.prototype.replaceAt = function(index, replacement) {
          return this.substr(0, index) + replacement + this.substr(index + replacement.length);
        }

        // format num to fit in n spaces.  We divide by d since some numbers are
        // scaled in various ways.  d is usually 1 though.
        function fmt( num, n, d ){
          d = d ||1;
          return ("                          "+Math.floor( num/d)).slice( - n );
        }

        // Save space with larger numbers by using K, M, G and T 'multipliers'
        function fmt2( num, d ){
          d = d ||1;
          var mul = " ";
          num = num/d;
          if( num > 100000 ){
            num = num/1000;
            mul = 'K';
          }
          if( num > 100000 ){
            num = num/1000;
            mul = 'M';
          }
          if( num > 100000 ){
            num = num/1000;
            mul = 'G';
          }
          if( num > 100000 ){
            num = num/1000;
            mul = 'T';
          }
          var n=6;

          return ("                          "+Math.floor( num)).slice( - n )+mul;
        }

        // These are the single letter codes for the ops.
        // By repeating a letter we can make it more likely to be used.
        // Q for quit reliably kills an organism, so we left it out.
        // Adding it lets you see how quickly a dead organism gets replaced.
        ops = "AVWXY0123456789E+-LSHRDM.";

        class Genome {

          // reset to start and all registers to zero.
          reset(){
            this.P = 0; // program counter
            this.A = 0;
            this.V = 0;
            this.W = 0;
            this.X = 0;
            this.Y = 0;
            this.Z = 0;
            this.Num = 0; // a temporary used to help with constants.
            this.op = "load"; // the initial operational mode.
            this.p = 128; // probability next operation succeeds (out of 256)
            return this;
          }

          // make one genome.
          constructor(){
            // this says 'mutate me like crazy'.
            this.genes =
              "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM";
            // Score is current average score.
            // Can climb to about 50,000,000.
            this.Score = 0;
            // s is a cumulative score.  Always increases.
            this.s = 0;
            // v,w,x,y are averaged V,W,X,Y values at recent evaluation times.
            // if we are doing perfectly they will all be 128.
            this.v = 0;
            this.w = 0;
            this.x = 0;
            this.y = 0;
            return this;
          }

          // mutate can
          //   delete a gene.  We add a NOP on the end.
          //   duplicate a gene
          //   mutate a gene.
          //
          mutate(){
            var ix = rand(64);
            var op = rand( ops.length );
            var ch = this.genes.substr( ix, 1 );
            var mut = rand( 40);

            //Experiment with NOPs only being deletable.
            //if( ch === "." )
            //  mut = 0;

            switch( mut )
            {
              // delete at
              //case 0:
              case 1:
                this.genes = this.genes.substr( 0, ix ) + this.genes.substr( ix+1, 64-ix )+".";//ops[op];
                break;
              // duplicate at
              case 2:
              //case 3:
                this.genes = this.genes.substr( 0, ix+1 ) + this.genes.substr( ix, 64-ix );
                break;
              // mutate at
              default:
                 this.genes = this.genes.replaceAt(ix, ops[op]);
            }
          }

          // This contains our fitness function
          evaluate(){

            // The fitness function rewards V and W being close
            // (and close to 128)
            // And rewards X and Y being close and close to 128.
            var d1 = Math.abs( this.V - this.W);
            var d2 = Math.abs( this.X - this.Y);

            var L1 = Math.abs(this.V + this.W) >> 1;
            var L2 = Math.abs(this.X + this.Y) >> 1;
            var S = 0;
            if( d1 < 15){
              // We're squaring to heavily reward close to 128.
              // there is a sharp peak there.
              if( L1 > 128 ) L1 = Math.max( 0, 255 - L1);
              S = L1 * L1;
            }
            if( d2 < 15){
              if( L2 > 128 ) L2 = 255 - L2;
              S += L2 * L2;
            }
            //Experiment with no score unless front legs shorter than rear legs.
            //if( L1 >= L2 )
            //  S=0;

            // Track the good v,w,x and y values.
            if( S > 25*25 ){
                //this.v +=Math.floor( (this.V - this.v) * 0.1);
                //this.w +=Math.floor( (this.W - this.w) * 0.1);
                //this.x +=Math.floor( (this.X - this.x) * 0.1);
                //this.y +=Math.floor( (this.Y - this.y) * 0.1);
                this.v = this.V;
                this.w = this.W;
                this.x = this.X;
                this.y = this.Y;
            }
            // Update our score.
            this.Score += S;
            this.reset();
          }

          // next instruction will always succeed.
          reliable(){
            this.p = 255;
          }

          // possibly duplicates this genome into a lower scoring competitor.
          duplicate(){
            // This next code discourages D from being too near the start.
            // This was necessary to prevent a genome spending all its time
            // duplicating and not getting on with scoring.
            // It's a gradual discouragement to help the genome learn how
            // much to delay duplicating by.
            if( rand(this.P) < 10 )
               return;

            // G2 is a competitor.
            var G2 = A.genomes[ rand( A.genomes.length )];
            // No penalty for duplicating, currently.
            var penalty=0;
            // Must be at least 1.1. times the competitor's score.
            var newscore = Math.floor((this.Score-G2.Score *1.1 ) - rand(penalty));
            document.getElementById("mut_freq").innerHTML = fmt(A.mutateInterval,7);

            // Stable at 100, if never duplicate.
            A.mutateInterval = Math.floor(A.mutateInterval*0.99+1);
            if( newscore <0 )
              return;
            // Stable at 100000 if always duplicate.
            A.mutateInterval += 99999;
            // We're about to take over G2.
            // Update my cumulative score (s)
            this.s += this.Score;
            // G2 now becomes a copy of this genome,
            // complete with scores.
            G2.genes = this.genes;
            G2.Score = this.Score;
            G2.v = this.v;
            G2.w = this.w;
            G2.x = this.x;
            G2.y = this.y;
            G2.s = this.s;
            //this.reset();
            // And we restart G2 from all zeroes too.
            G2.reset();
          }

          // quit forgets my genes, which is usually lethal.
          quit(){
            // Q is lethal, so don't do it too often!
            if( rand( 10 ) !== 0 )
              return;
            this.Score=0;
            this.s=0;
            this.P=0;
            // all genes gone.  They are now to mutate.
            this.genes =
              "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM";
          }


          // In the following, A is the accumulator.
          nop(){
          }
          load( ch ){
            this.A = this[ch];
          }
          store( ch ){
            this[ch] = this.A;
          }
          add( ch ){
            this.A = (this.A + this[ch]) & 0xFF;
          }
          sub( ch ){
            this.A = (this.A - this[ch]) & 0xFF;
          }

          // We've chosen that 'halve' always halves the accumulator,
          // no matter what argument was specified.
          halve( ch ){
            this.A = (this.A>>1);
          }

          // call the currently selected operator function on the desired
          // target register.
          doOpTo( targetRegister ){
            this[this.op]( targetRegister );
          }

          // set the currently selected operator function.
          setOpTo( op ){
            this.op = op;
          }

          // obey one opcode.
          dispatch( ch ){
            switch( ch ){

              case "A":
              case "V":
              case "W":
              case "X":
              case "Y":
              case "Z":
                this.doOpTo( ch );break;

              // 0 to 9 are constants, so we use Num as a proxy
              // and we don't care about the result (we discard it).
              // So for example S8 is a NOP, wheareas L8 loads 8.
              case "0":this.Num = 0;this.doOpTo( "Num" );break;
              case "1":this.Num = 1;this.doOpTo( "Num" );break;
              case "2":this.Num = 2;this.doOpTo( "Num" );break;
              case "3":this.Num = 3;this.doOpTo( "Num" );break;
              case "4":this.Num = 4;this.doOpTo( "Num" );break;
              case "5":this.Num = 5;this.doOpTo( "Num" );break;
              case "6":this.Num = 6;this.doOpTo( "Num" );break;
              case "7":this.Num = 7;this.doOpTo( "Num" );break;
              case "8":this.Num = 8;this.doOpTo( "Num" );break;
              case "9":this.Num = 9;this.doOpTo( "Num" );break;

              case "E":this.evaluate( );break;
              case "Q":this.quit( );break;


              case "+":this.setOpTo( "add" );break;
              case "-":this.setOpTo( "sub" );break;
              case "L":this.setOpTo( "load" );break;
              case "S":this.setOpTo( "store" );break;
              case "H":this.setOpTo( "halve" );break;

              case "R":this.reliable( );break;
              case "D":this.duplicate( );break;
              case "M":this.mutate( );break;
              case ".":this.nop();break;

              default:
            }

          };

          step(){
            // get the opcode
            var ch = this.genes[ this.P ];
            // update program counter.
            if( this.P >= this.genes.length -1 )
              this.reset();
            else
              this.P = (this.P+1) % this.genes.length;

            // 50 % chance of a NOP.
            if( rand( 256 )>this.p )
              ch = ".";// Nop.
            // reset probability to some number between 138 and 246
            this.p = 138 + Math.min( 9, this.Num) *12 ;

            // Alternative opcode probabilities:

            // Highly reliable setting.
            //this.p = 250;

            // Standard reliability setting (opcodes work 50% of time)
            //this.p = 128;

            // and actually go and do the opcode.
            this.dispatch(ch);

            // Very occasional mutation.
            // Note that if you stay running in the first 41 characters
            // you won't mutate.
            if( rand( Math.floor(A.mutateInterval)) ===0 )
              if( this.P > 41 )
                this.mutate();
          }
        }

        // Make 50 genomes.
        function makeGenomes(A){
          A.genomes=[];
          const n = 50;
          for(i=0;i<n;i++){
            G = new Genome;
            G.reset();
            A.genomes.push( G );
          }
        }

        // Show all the genomes.
        function showGenes(A){
          str = "";
          A.genomes.forEach( function(G,index){
            str += G.genes + fmt(index,3)+
//              " PC:"+fmt(G.P, 4) +
//              " A:"+fmt(G.A, 4) +
//              " N:"+fmt(G.Num, 4) +
              " V:"+fmt(G.v, 4,1) +
              " W:"+fmt(G.w, 4,1) +
              " X:"+fmt(G.x, 4,1) +
              " Y:"+fmt(G.y, 4,1) +
//              " Z:"+fmt(G.Z, 4) +
              " S:"+fmt2(G.s) +
              " S1:"+fmt2(G.Score) +
              "\n";
          });
          A.list.value = str;
        }


        function mutateGenes(A){
          A.genomes.forEach( function(G,index){
            G.mutate();
          });
        }

        // Run one instruction for each genome.
        function stepGenes(A){
          A.genomes.forEach( function(G,index){
            G.step();
          });
        }

        // This is about averaging the score.
        // Score will be 100x the score obtained each iteration,
        // since we score down by 0.99
        function scoredownGenes(A){
          A.genomes.forEach( function(G,index){
            G.Score = Math.floor( G.Score * 0.99 );
          });
        }

        function reReadGenomes(){
          var str = document.getElementById("gene_list").value;
          str = str.split( "\n" );
          str.forEach( function( line, i ){
            if( i< 50 ){
              var g = line.split(" ")[0];
              A.genomes[i].genes = g;
              console.log("" + fmt(i, 2) + " " + g);
            }
          });
        }

        function pauseGo(btn){
          if( !A.active )
            reReadGenomes();
          A.active = !A.active;
          btn.innerHTML = A.active ? "Pause" : "Go";

        }
        // Every tick, run 1000 ops on each genome, average in the score and
        // update the screen.
        function timerCallback(){
          if( !A.active )
            return;
          for( var i=0;i<1000;i++)
            stepGenes( A );
          scoredownGenes(A);
          showGenes(A);
        }

      // Start the whole thing up
      window.onload = function(){
        // where to show results.
        A.list = document.getElementById("gene_list");

        makeGenomes(A);
        // all the work happens in the timer ticks.
        A.active = true;
        A.mutateInterval = 10000;
        setInterval(timerCallback, 30);

      }

    </script>
</head>
<body id="body"
      style="background-image:url(./images/header-light-bg.jpg);margin:0px;background-attachment:fixed;">
<div style="width:100%; text-align:center;background:#1d2134;height:5em;margin: 0px;">
    <h1 style="color:white;margin:0px;padding-top:0.65em;padding-bottom:0.9em;"><em>Genes</em>: Demo Page</h1>
    <div style="width:100%; text-align:center;background:#303b70;position:relative;height:1.8em;top:-0.6em;box-shadow: inset 0 0px 4px 0px #000080, 0 -2px 7px -2px #618ef4;"></div>
</div>
<div style="width:100%;position:relative;top:-0.50em;left:0;display:inline-block;margin:0 auto;height:3em;">
    <div class='pos-resetter'>
        <h2 id="click-tip"
            style="color:#bfbfbf;display:block;position:relative;top:-0.55em;transition:opacity 4s;opacity:1;">
            <em>Version A from 22-Aug-2020</em></h2>
    </div>
</div>
<a href="https://www.audacityteam.org">
    <div id="logoback">
        <img id='logo' src="./images/audacity-logo.png">
    </div>
</a>
<div style="height:1.9em;"></div>

<div id="content_here0" class="atkContentDiv" data-page="Audacity" style="text-align:center;">
    <div style="display:none">
    <pre>IMAGE:NAME=svg</pre>
    [[File:AudacityAu19HS.png]]
    </div>
</div>

<textarea id="gene_list" style="margin-left:10px;width:1060px;height:800px;" spellcheck="false">
    aaaaaaa
    bbbbb
    ccccc
</textarea>
<button id="pause_button" onclick="pauseGo(this);">Pause</button>
Mutations every: <span id="mut_freq">0000</span> cycles
<div style="margin-left:10px;color:#818181">
    <div id="message"></div>
    <div id="message2"></div>
</div>


<div id="examples" style="margin-left:20px">
</div>

</body>
</html>