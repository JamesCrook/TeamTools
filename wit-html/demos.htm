<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Automation Images</title>
    <style type="text/css">
        h1 { font-size: 2em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.17em; }
        h4 { font-size: 1.12em; }
        h5 { font-size: .83em; }
        h6 { font-size: .67em; }

        html *
        {
            font-family: Arial;
        }

        #logoback {
            transition: all 0.15s;
            background-color: #edebfc;
            border: 2px solid;
            border-color: #edebfc;
            position:absolute;
            top:1.25em;
            left:0.9375em;
            width:5.75em;
            height:5.75em;
            color:black;
            box-sizing:border-box;
            line-height:5.75em;
            border-radius:2.875em;
            box-shadow:0px 0px 1.25em 1px #000080;"

        }
        #logoback:hover {
            /*background-color: #c7cfff;*/
            border-color: #848ff8;
        }
        #logo
        {
            position:relative;
            top:0.5em;
            left:0.5625em;
            transition: all 0.1s;
            width:4.375em;
            height:4.375em;

        }
        #logo:hover
        {
            /*top:6px;*/
            /*transform: rotate(10deg);*/
        }
        #logo:hover:active {
            width:5em;
            height:5em;
            left:0.25em;
            top:0.0625em;
        }

        pre {
            background-color: #1d2134;
            color: yellow;
        }
        div.bt {

            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;

            display:inline-block;
            color:black;
            font-size:13px;
            border: 1px solid;
            padding:2px 15px 2px 15px;
            border-color: #8696b2;
            background-color: #c5d4fc;
            box-shadow: inset 0 -5px 5px 0 #a6c1e7;
        }
        div.bt:hover {
            cursor: pointer;
            /*box-shadow: inset 0 -5px 15px 0 #7c94b7;*/
            background-color: #a9bdff;
            border-color: #2130ba;
        }
        div.bt:hover:active {
            background-color: #a5c3ee;
            box-shadow: inset 0 2px 5px 0 #7c94b7;
        }
        div.linky {
            transition: all 0.15s;
            display:none;
            background-color: #c5d4fc;
            border: 2px solid;
            border-color: #c5d4fc;
            /*border-color: #8696b2;*/
            padding:0px 1.25em 0px 1.25em;
            color:black;
            height:2.25em;
            line-height:2.25em;
            box-sizing:border-box;
            border-radius:1.25em;
            margin:0 auto;
            box-shadow:0 0 20px 1px #000080;
            cursor: pointer;

        }
        div.linky:hover {
           /* background-color: #a5c3ee;*/
            border-color: #848ff8;

        }

        div.pos-resetter {
            width:100%;
            display:inline-block;
            text-align:center;
            position:absolute;
            margin:0 auto;
        }

        div.detaildiv
        {
            padding: 20px;
            box-sizing: border-box; /* so the div is exactly the requested size.*/
            border: 1px solid #000;
            border-radius: 5px;
            -moz-border-radius: 5px;
            text-align:left;
            margin:0px;
        }

        div a
        {
            color: #f5b40b;
        }

        div.detaildiv a
        {
            color: #f5b40b;
        }

        img.centred {
            position: absolute;
            top: -9999px;
            left: -9999px;
            bottom: -9999px;
            right: -9999px;
            margin:auto;
        }
    </style>
    <script>
        console.log( "Protocol is "+window.location.protocol);
        if (window.location.protocol == "http:"){
            console.log("Http: detected");
            if( window.location.href.indexOf("localhost") < 0 )
                window.location.href = "https:" + window.location.href.slice(5);
        }

        // MDN Pollyfill for startsWith
        if (!String.prototype.startsWith) {
            String.prototype.startsWith = function(searchString, position){
                position = position || 0;
                return this.substr(position, searchString.length) === searchString;
            };
        }


        var Annotator = {};

        var A=Annotator;
        A.Spec ={}; // the unparsed spec from wiki arrives here.
        A.Porthole = {};
        A.Porthole.width = 1024;
        A.Porthole.height = 567;
        A.Porthole.margin = 5;
        A.Image = {};
        A.Image.imageSrc = './images/AudacityAu19.jpg';
        A.Hotspots = {};
        A.Hotspots.imageSrc = './images/AudacityAu19HS.png';
        A.Focus = {};
        A.Focus.radius = 150;
        A.Detail = {};
        A.Detail.width = 400;
        A.Detail.height = 300;

        A.AddHot = function( index ){
            var actions = {};
            A.Hotspots.Colours[ index ] = actions;
            A.Hotspots.Colours[ roundColour(index) ] = actions;
            A.Hotspots.Current = actions;
            actions.Zone = A.Hotspots.count++;
        };

        var Nozone={};
        Nozone.Zone = 0;

        function resetHotspots(){
            var A = Annotator;
            A.Hotspots.Colours = [];
            A.Hotspots.count = 0;
            // Bogus entry to catch bad tips.
            A.AddHot( "[5,0,0,0]" );

            A.Buttons = {};
            A.Buttons.Names = [];
            A.Buttons.chosen = -1;

            A.RootObject = {};
            A.Distortion = {};
        }

        resetHotspots();


        A.AddButton = function( text ){
            A.Buttons.Names.push( text );
            A.AddHot( "[0,10,"+ A.Buttons.Names.length*5 + ",255]");
        };

        A.AddInfo = function( ){
            A.AddHot( "[0,0,5,255]");
        };

        A.AddDetail = function( text ){
            A.Hotspots.Current.Tip = text;
        };

        A.AddHover = function( text ){
            A.Hotspots.Current.Hover = text;
        };

        var Status = {};
        Status.OldHit = -1;
        Status.imagesToCome = 2;
        Status.time = 0;

        var Message;
        var Message2;


        function resizeDivs(){
            var A = Annotator;
            A.MainDiv.style.width = A.Porthole.width+'px';
            A.MainDiv.style.height = A.Porthole.height+'px';
            A.BackingCanvas.width = A.Porthole.width;
            A.BackingCanvas.height = A.Porthole.height;
            A.FocusCanvas.width = A.Porthole.width;
            A.FocusCanvas.height = A.Porthole.height;
            A.DetailDiv.style.width = A.Detail.width+'px';
            A.DetailDiv.style.height = A.Detail.height+'px';
            A.Hotspots.canvas.width = A.Porthole.width;
            A.Hotspots.canvas.height = A.Porthole.height;
            A.Hotspots.ctx = A.Hotspots.canvas.getContext('2d');
        }


        function resizeForImage(img){
            //alert( "RESIZING "+img.width +"x"+img.height );
            A.Porthole.width = img.width;
            A.Porthole.height = img.height;
            // resizeDivs();
            if( Status.isAppReady )
                onChart();
        }

        function innerDraw(){
            Status.drawing = true;
            var ctx = A.BackingCanvas.ctx;
            var ctx2 = A.Hotspots.ctx;
            ctx.clearRect( 0,0, A.Porthole.width, A.Porthole.height );
            ctx2.clearRect( 0,0, A.Porthole.width, A.Porthole.height );
            drawArrows();
            drawCells(A.RootObject, {});
            drawArrowHeads();

            drawButtons();
            Status.drawing = false;
        }
        function onChart(){
            var A = Annotator;
            console.log("onChart");
            A.Detail.width = A.Porthole.width / 2-10;
            A.Detail.height = Math.min( 300,A.Porthole.height -100);

            resizeDivs();

            var d={};
            sizeCells(A.RootObject,d);
            d.margins=10;
            layoutCells(0, 0, A.Porthole.width, A.Porthole.height, A.RootObject,d);
            //console.log(A.RootObject.content );
            innerDraw();
            Status.isAppReady = true;

        }

        function timerCallback(){
            Status.time++;
            if( !Status.drawing )
               innerDraw();
        }

        function onFailedImage(){
            alert("Image failed to load");
        }

        function detailPosFromCursorPos( x,y ){
            var A = Annotator;
            var pt = {};
            // get position as somewhere in range -1..+1
            var vx = 2.0*x/A.Porthole.width-1;
            var vy = 2.0*y/A.Porthole.height -1;

            // Detail panel will be hard right or hard left.
            vx = (vx>0) ? -1:1;

            // Message2.innerHTML = "Vec: ("+vx+","+vy+")";
            pt.x = (vx+1) * (A.Porthole.width - A.Detail.width) * 0.5;
            pt.y = (vy+1) * (A.Porthole.height - A.Detail.height) * 0.5;

            return pt;
        }

        function drawBar( T,values,i,ix ){
            var A = Annotator;
            var vx = values[i][ix];
            var x = i * T.xScaler;
            var y = vx * T.yScaler;
            var ctx = A.BackingCanvas.ctx;
            ctx.beginPath();
            ctx.rect(T.margin+x+(ix-1)* T.width+ T.x0, T.yh-(T.margin+y)+ T.y0, T.width, y);
            ctx.fillStyle =
                    (ix!=1)?"rgba(105,205,105,1.0)":"rgba(105,105,205,1.0)";
            ctx.fill();
            ctx.stroke();
        }

        function drawLabel( T,values,i ){
            var ctx = A.BackingCanvas.ctx;
            var x = i * T.xScaler+ T.width;
            var y = -11;
            ctx.save();
            ctx.translate(T.margin+x+ T.x0, T.yh-(T.margin+y)+ T.y0);
            ctx.rotate(-Math.PI/4);
            ctx.textAlign = "right";
            ctx.fillStyle = "rgba(15,35,165,1.0)";
            ctx.fillText(values[i][0], 0, 0);
            ctx.restore();
        }

        function clearBacking(x0, y0, xw, yh){
            var A = Annotator;

            var ctx = A.BackingCanvas.ctx;
            ctx.beginPath();
            ctx.fillStyle = "rgba(205,205,205,1.0)";
            ctx.strokeStyle = "rgba( 55, 55,155,1.0)";
            ctx.lineWidth = 1;

            ctx.rect(x0 + 5, y0 + 5, xw - 10, yh - 10);
            ctx.fill();
            ctx.stroke();
        }
        function computeSpacing(T, x0, y0, xw, yh, values){
            T.x0 = x0;
            T.y0 = y0;
            T.xw = xw;
            T.yh = yh - 20;
            T.count = T.count || values.length;
            T.items = T.items || (values[0].length - 1);
            T.margin = 60;
            if( T.width )
                T.spacer = (xw - 2 * T.margin - T.count * T.width * T.items) /
                    (T.count - 1);
            else {
                T.spacer = T.spacer || 4;
                T.width = ((xw+ T.spacer-2 * T.margin ) / T.count - T.spacer )/ T.items;
            }
            T.xScaler = (T.width* T.items  + T.spacer);
            T.yScaler = (Math.min(20, Status.time) / 20) * (yh - 2 * T.margin) /
                    2000.0;
        }
        function drawSpacedItems(x0,y0,xw,yh, values, fn, T){
            clearBacking(x0, y0, xw, yh);

            if( !values )
                    return;
            computeSpacing(T, x0, y0, xw, yh, values);
            for(i=0;i< T.count;i++){
                for( j=0;j< T.items;j++)
                    fn( T, values, i, 1+j );
                drawLabel( T, values, i );
            }
        }

        function drawChart3( x0,y0,xw,yh, obj ){
            var T={};
            T.width = 8;
            drawSpacedItems(x0,y0,xw,yh, obj.values, drawBar, T);
        }

        function drawDonut( T,values,i,ix ){
            var A = Annotator;
            var xw = T.width;
            var x = i * T.xScaler+ T.margin + T.x0+xw/2;
            var y = T.y0 + T.yh - T.margin - T.width+xw/2;
            var r = xw/2;
            var r2 = r*0.40;
            var t0 = 2.0*Math.PI *0.75;
            var t1 = 2.0*Math.PI *0.75;
            var colours = ["rgba(105,205,105,1.0)","rgba(105,105,205,1.0)"];

            // get total
            var total =0;
            var j;
            for(j=1;j<values[i].length;j++)
                total = total + values[i][j];

            var ctx = A.BackingCanvas.ctx;

            var frac = Math.min(20, Status.time) / 20;

            for(j=1;j<values[i].length;j++){
                t0=t1;
                t1=t1+ frac * Math.PI*2*values[i][j]/total;
                ctx.beginPath();
                ctx.moveTo(x + r2 * Math.cos(t0), y + r2 * Math.sin(t0));
                ctx.lineTo(x + r * Math.cos(t0), y + r * Math.sin(t0));
                ctx.arc(x, y, r, t0, t1, false);
                ctx.lineTo(x + r2 * Math.cos(t1), y + r2 * Math.sin(t1));
                ctx.arc(x, y, r2, t1, t0, true);
                ctx.closePath();
                //ctx.rect(x, y, T.width, T.width);
                ctx.fillStyle = colours[j % 2];
                ctx.fill();
                ctx.stroke();
            }
        }

        function drawPieChart(x0,y0,xw,yh, obj ){
            var T={};
            //T.width = 100;
            T.spacer = 30;
            T.items =1;
            drawSpacedItems(x0,y0,xw,yh, obj.values, drawDonut, T);
        }

        function drawHotspots(){
            var A = Annotator;
            var extra = A.Buttons.Names.length ? 25 : 0;
            var img = A.Hotspots.img;
            A.Hotspots.ctx.drawImage(img, 0, extra, img.width, img.height);
            drawButtons();
        }

        // slice is a number from -1 to +1.
        // source is a number from 0 to 1.
        function sourceForSlice( slice ){
            return Math.acos( -slice )/Math.PI;
        }

        function drawSphere(xx,yy,xw,yh,obj){
            xw = Math.floor(xw);
            yh = Math.floor(yh);
            //console.log( "Draw at "+xx+","+yy+" ["+xw+" by "+yh+"]");
            var A = Annotator;
            var ctx = A.BackingCanvas.ctx;
            var ctx2 = obj.ctx;
            var img = obj.img;
            //console.log( "From image "+img.width+" by "+img.height);
            if( !ctx2 ){
                obj.canvas = document.createElement( "canvas" );
                obj.canvas.width = img.width;
                obj.canvas.height = img.height;
                obj.ctx = obj.canvas.getContext('2d');
                ctx2 = obj.ctx;
            }
            ctx2.drawImage(img, 0, 0, img.width, img.height);
            var x0 = xw/2;
            var rotate = img.width - ((Status.time*3)%img.width);

            var offsets=[];
            for(i=0;i<img.width;i++){
                d= Math.floor(Math.asin( i/img.width)*(img.width)/4)*4;
                offsets.push(d);

            }

            var w = Math.floor(xw/2);
            var h1 = Math.floor(yh/2);
            var h = Math.min(h1,w);


            var srcData = ctx2.getImageData( 0, 0, img.width, img.height);
            //var dstData = ctx.createImageData( h*2,h*2) ;

            var dstData = ctx.getImageData(xx+(w-h), yy+(h1-h),h*2,h*2);


            for( var y=-h;y<h;y++){
                var dx= Math.floor(Math.sqrt( h*h - y*y));
                var srcLine = Math.floor(sourceForSlice(y/h)*img.height);
                var srcBase = (srcLine*img.width+rotate) *4;
                var index = Math.floor((y+h)*h*2 +h-dx)*4;
                var rescaler =(img.width-1)/dx;
                var srcIndex;
                var offset;
                var src = srcData.data;
                var dst = dstData.data;
                //console.log( 'row:'+y+' ('+(h-dx)+'..'+(h+dx)+')');
                for( var x = -dx; x<dx;x++){
                    // This inner loop has had a little TLC for speed.
                    // Taking 25% of CPU to 15% by taking calculations
                    // outside the loop.
                    offset = offsets[ Math.floor( Math.abs(x)*rescaler) ];
                    if( x<0 )
                        srcIndex = srcBase - offset;
                    else
                        srcIndex = srcBase + offset;

                    if( src[srcIndex+3] < 128 ){
                        dst[index++] = 20;
                        dst[index++] = 20;
                        dst[index++] = 110;
                        dst[index++] = 100;
                    }
                    else
                    {
                        dst[index++] = src[srcIndex++];
                        dst[index++] = src[srcIndex++];
                        dst[index++] = src[srcIndex++];
                        dst[index++] = src[srcIndex++];
                    }
                }
            }
            //ctx.clearRect(xx,yy,xw,yh);
            ctx.putImageData( dstData, xx+(w-h), yy+(h1-h) );
        }

        function drawButtons(){
            var A = Annotator;
            var xw = 60;
            var yh = 25;
            var gap = 9;
            var n = A.Buttons.Names.length;
            var m = 1;
            // grid of n by m buttons, with gaps between them.
            var x = (A.Porthole.width  - n *(xw+gap) + gap) *0.5;
            var y = 0;//(A.Porthole.height - m *(yh+gap) + gap) *0.5;
            var ctx = A.BackingCanvas.ctx;
            var ctx2 = A.Hotspots.ctx;
            ctx.lineWidth = 3;
            ctx.font="16px Arial";
            ctx.strokeStyle = "rgba( 55, 55,155,1.0)";
            ctx2.lineWidth = 0;

            var i;
            for( i=0;i<n;i++){
                var xx = x + i * (xw + gap);
                var yy = y + 1;
                ctx.beginPath();
                if( (i+1)== A.Buttons.chosen )
                    ctx.fillStyle = "rgba(255,255,255,1.0)";
                else
                    ctx.fillStyle = "rgba(205,205,205,1.0)";

                ctx.rect(xx, yy, xw, yh);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "rgba(0,0,0,1.0)";
                ctx.fillText(A.Buttons.Names[i], xx+11, yy+18 );
                ctx2.beginPath();
                ctx2.fillStyle = "rgba(0,10,"+(i+1)*5+",1.0)";
                ctx2.rect( x + i*(xw+gap), y+ 0*(yh+gap), xw, yh);
                ctx2.fill();
            }
            drawInfoButtonHotspot();
        }

        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2*r) r = w / 2;
            if (h < 2*r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x+r, y);
            ctx.arcTo(x+w, y,   x+w, y+h, r);
            ctx.arcTo(x+w, y+h, x,   y+h, r);
            ctx.arcTo(x,   y+h, x,   y,   r);
            ctx.arcTo(x,   y,   x+w, y,   r);
            ctx.closePath();
        }

        function setStyles( ctx, obj ){
            ctx.lineWidth = 3;
            ctx.font="16px Arial";
            ctx.globalCompositeOperation = 'source-over';

            if( obj.colour )
                ctx.fillStyle = obj.colour;
            else
                ctx.fillStyle = "rgba(255,255,255,1.0)";

            if( obj.bcolour )
                ctx.strokeStyle = obj.bcolour;
            else
                ctx.strokeStyle = "rgba( 55, 55,155,1.0)";
        }

        function drawArrow( obj1, obj2 ){
            var A = Annotator;
            var ctx = A.BackingCanvas.ctx;
            var x1 = obj1.layout.x0 + obj1.layout.xw/2;
            var x2 = obj2.layout.x0 + obj2.layout.xw/2;
            var y1 = obj1.layout.y0 + obj1.layout.yh/2;
            var y2 = obj2.layout.y0 + obj2.layout.yh/2;
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,1.0)";
            ctx.lineWidth = 3;
            ctx.moveTo( x1,y1);
            ctx.lineTo( x2,y2);
            ctx.stroke();
        }

        function drawArrowHead( obj1, obj2 ){
            var A = Annotator;
            var ctx = A.BackingCanvas.ctx;
            var x1 = obj1.layout.x0 + obj1.layout.xw/2;
            var x2 = obj2.layout.x0 + obj2.layout.xw/2;
            var y1 = obj1.layout.y0 + obj1.layout.yh/2;
            var y2 = obj2.layout.y0 + obj2.layout.yh/2;
            ctx.beginPath();
            ctx.fillStyle = "rgba(0,0,0,1.0)";
            ctx.lineWidth = 1;
            var vx = x1-x2;
            var vy = y1-y2;
            var theta = -Math.atan2( vx, vy)-Math.PI/2;
            var m=0;
            if( obj2.type == "Circle" ){
                var r= Math.min(obj2.layout.yh,obj2.layout.xw)/2;
                m = 0.93*r/Math.sqrt( vx*vx+vy*vy);
            } else {
                m = 1;//0.5;

                if( Math.abs(vx)*obj2.layout.yh >
                        Math.abs(vy)*obj2.layout.xw )
                    m= obj2.layout.xw /(2*Math.abs(vx));
                else
                    m= obj2.layout.yh /(2*Math.abs(vy));
                m = m *0.93;

            }
            x2 =x2+m*vx;
            y2 =y2+m*vy;


            ctx.save();
            ctx.translate(x2, y2);
            ctx.rotate(theta);
            ctx.moveTo( -11,-5);
            ctx.lineTo( 0,0);
            ctx.lineTo( -11,5);
            ctx.lineTo( -7,0);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }


        function drawImage( x,y,xw,yh, obj )
        {
            var A = Annotator;
            var ctx = A.BackingCanvas.ctx;
            var ctx2 = A.Hotspots.ctx;
            if( obj.status != "arrived" ){
                drawRectangle( x,y,xw,yh,obj );
            }
            else if( obj.spherical ){
                drawSphere( x,y,xw,yh, obj);
            } else {
                ctx.drawImage(obj.img, x, y, xw, yh);
                if( obj.hot && obj.hot.status == "arrived" )
                    ctx2.drawImage(obj.hot.img, x, y, xw, yh);
            }
        }


        function drawRectangle( x,y,xw,yh, obj )
        {
            var A = Annotator;
            var ctx = A.BackingCanvas.ctx;

            ctx.save();
            ctx.beginPath();

            setStyles( ctx, obj );
            if( obj.corner_radius )
                roundRect( ctx, x,y,xw,yh, obj.corner_radius);
            else
                ctx.rect(x, y, xw, yh);
            ctx.fill();
            ctx.stroke();

            ctx.textAlign = "center";
            ctx.fillStyle = "rgba(0,0,0,1.0)";
            ctx.fillText( obj.value, x+xw/2, y+yh/2+6 );
            ctx.restore();
            if( obj.hotspotColour ){
                var ctx2 = A.Hotspots.ctx;
                ctx2.beginPath();
                ctx2.rect(x, y, xw, yh);
                ctx2.fillStyle = obj.hotspotColour;
                ctx2.fill();
            }
        }

        function drawCircle( x,y,xw,yh, obj )
        {
            var A = Annotator;
            var ctx = A.BackingCanvas.ctx;
            ctx.lineWidth = 3;
            ctx.font="16px Arial";
            ctx.globalCompositeOperation = 'source-over';

            ctx.save();
            ctx.beginPath();
            setStyles( ctx, obj );

            var r = Math.min( xw, yh )/2;
            ctx.arc(x+xw/2, y+yh/2, r, 0, Math.PI * 2.0, true);
            ctx.fill();
            ctx.stroke();

            ctx.textAlign = "center";
            ctx.fillStyle = "rgba(0,0,0,1.0)";
            ctx.fillText( obj.value, x+xw/2, y+yh/2+6 );
            ctx.restore();
            if( obj.hotspotColour ){
                var ctx2 = A.Hotspots.ctx;
                ctx2.beginPath();
                ctx2.arc(x+xw/2, y+yh/2, r, 0, Math.PI * 2.0, true);
                ctx2.fillStyle = obj.hotspotColour;
                ctx2.fill();
            }
        }

        function drawInfoButtonHotspot(){
            var A = Annotator;
            var xw = 25;
            var yh = 25;
            var x = 5;
            var y = 5;
            var ctx2 = A.Hotspots.ctx;
            ctx2.lineWidth = 0;
            ctx2.beginPath();
            ctx2.fillStyle = "rgba(0,0,5,1.0)";
            ctx2.rect(x, y, xw, yh);
            ctx2.fill();
        }


        function objFromId( id ){
            if( !isDefined( id ))
                return id;
            var A = Annotator;
            return A.RootObject.objectDict[ id.substr(0,10)];
        }

        function drawArrowThing( fn ){
            var A = Annotator;
            var arrows = A.RootObject.arrows;
            if( !isDefined( arrows ))
                return;
            for(i=0;i<arrows.length;i+=2){
                var obj1 = objFromId( arrows[i] );
                var obj2 = objFromId( arrows[i+1] );
                if( !isDefined( obj1 ) || !isDefined( obj2))
                    return;
                fn( obj1, obj2 );
            }
        }


        function drawArrows(){
            drawArrowThing( drawArrow );
        }

        function drawArrowHeads(){
            drawArrowThing( drawArrowHead );
        }

        function drawInfoButton(){
            var A = Annotator;
            var xw = 25;
            var yh = 25;
            var x = 5;
            var y = 5;
            var ctx = A.FocusCanvas.ctx;
            ctx.lineWidth = 3;
            ctx.font="20px Times New Roman";
            ctx.strokeStyle = "rgba( 55, 55,155,1.0)";
            ctx.globalCompositeOperation = 'source-over';

            ctx.beginPath();
            ctx.fillStyle = "rgba(255,255,255,1.0)";

            ctx.arc(x+xw/2, y+yh/2, xw/2, 0, Math.PI * 2.0, true);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = "rgba(0,0,0,1.0)";
            ctx.fillText( "i", x+9, y+19 );
        }


        function drawFocusSpot( x, y ){
            var A = Annotator;
            var ctx= A.FocusCanvas.ctx;
            var extra = A.Buttons.Names.length ? 25 : 0;


            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0,0, A.Porthole.width, A.Porthole.height);

            if( y<extra )
                return;

            var m = A.Porthole.margin;
            ctx.fillStyle = "rgba( 255,255,255,0.5)";

            ctx.fillRect(m,m+extra, A.Porthole.width-2*m, A.Porthole.height-2*m-extra);

            ctx.fillStyle = "rgba(0,255,255,1.0)";
            ctx.globalCompositeOperation = 'destination-out';


            ctx.beginPath();
            ctx.arc( x, y, A.Focus.radius, 0, Math.PI * 2.0, true );
            ctx.closePath();
            ctx.fill();
        }

        function roundColour( tuple ){
            var values = JSON.parse( tuple );
            var result = values.map( function( v ){
                return Math.floor((v+2.5)/5) *5;});
            return '['+result.toString() + ']';
        }

        function rgbOfColourTuple( tuple ){
            var v = JSON.parse( tuple );
            return "rgba("+v[0]+","+v[1]+","+v[2]+","+v[3]+")";
        }

        function removeAdornments(e){
            if( !Status.isAppReady )
                return;
            if( e.shiftKey )
               return;
            var A = Annotator;
            var ctx= A.FocusCanvas.ctx;
            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0,0, A.Porthole.width, A.Porthole.height);
            A.DetailDiv.style.display = "none";
            Status.OldHit = -1;
        }

        function actionsFromCursorPos( x, y, flags ){
            var A=Annotator;
            if( !A.Hotspots.ctx )
                return -1;
            var pixel = A.Hotspots.ctx.getImageData(x,y,1,1).data;
            var result= "["+pixel[0]+","+pixel[1]+","+pixel[2]+","+pixel[3]+"]";
            var actions =
                    A.Hotspots.Colours[result] ||
                    A.Hotspots.Colours[roundColour( result )] ||
                    Nozone;
            if( Message2 )
                Message2.innerHTML = "Colour &amp; Zone: rgba" + result + ", Zone "+actions.Zone;
            if( flags == "log" )
                console.log( roundColour( result ) + "," );
            return actions;
        }

        function setNewImage( url ){
            var A=Annotator;
            // Only supported for whole-div images.
            if((A.RootObject.content.length == 1) &&
                    (A.RootObject.content[0].type == "Image" )){
                var obj = A.RootObject.content[0];
                obj.file = url;
                obj.img.src = obj.file;
            }

        }

        function doAction( action ){
            var A=Annotator;
            if( action.Action == "Spec" )
                requestSpec(action.Name, A.fromWiki);
            else if( action.Action == "Image" )
                setNewImage(action.Name);
            else if( action.Action == "Goto" ){
                window.location.href = action.Name;
            }

        }

        function mousemoveOnMap(e){
            if( !Status.isAppReady )
                return;

            var A=Annotator;
            if( e.shiftKey )
                    return;

            var rect = e.target.getBoundingClientRect();
            var x = e.clientX -rect.left;
            var y = e.clientY -rect.top;
            var coordinates = "Coordinates: (" + x + "," + y + ")";

            var pt = detailPosFromCursorPos( x, y);

            drawFocusSpot( x,y );
            drawInfoButton();
            var actions = actionsFromCursorPos(x,y);
            if( Message )
                Message.innerHTML = coordinates;
            A.DetailDiv.style.left = pt.x+"px";
            A.DetailDiv.style.top = pt.y+"px";
            if( Status.OldHit != actions.Zone ){
                Status.OldHit = actions.Zone;

                // Update the detail div
                A.DetailDiv.style.display = ( actions.Tip )?"block":"none";
                if( actions.Tip){
                    A.DetailDiv.innerHTML = actions.Tip;
                }
                // Do any additional hover action
                if( actions.Hover ){
                    A.Buttons.chosen = actions.Zone;
                    doAction( actions.Hover );
                }
                e.target.style.cursor =
                    actions.Click ? 'pointer' : 'auto';
            }
        }

        function onFocusClicked(e){
            if( !Status.isAppReady )
                return;

            if( e.shiftKey )
                return;

            var rect = e.target.getBoundingClientRect();
            var x = e.clientX -rect.left;
            var y = e.clientY -rect.top;

            var actions = actionsFromCursorPos(x,y,"log");
            if( actions.Click ){
                doAction( actions.Click );
            }
        }


        function createDomElements(){
            var A=Annotator;
            var contentHere= document.getElementById("content_here");

            // Used for debugging messages
            Message= document.getElementById("message");
            Message2= document.getElementById("message2");

            // MainDiv contains all the other divs
            A.MainDiv = document.createElement( "div");
            // Backing canvas has the image drawn into it
            A.BackingCanvas = document.createElement( "canvas" );
            // Focus canvas has the white-out with focus circle
            A.FocusCanvas = document.createElement( "canvas" );
            // Detail div floats above the white-out
            A.DetailDiv = document.createElement( "div" );

            contentHere.appendChild( A.MainDiv );
            A.MainDiv.appendChild( A.BackingCanvas );
            A.MainDiv.appendChild( A.FocusCanvas );
            A.MainDiv.appendChild( A.DetailDiv );

            A.MainDiv.style.position="relative";
            A.MainDiv.style.display="inline-block";
            A.MainDiv.style.marginLeft="auto";
            A.MainDiv.style.marginRight="auto";
            A.MainDiv.style.overflow="hidden";

            A.BackingCanvas.style.position = "absolute";
            A.BackingCanvas.style.left = "0px";
            A.BackingCanvas.style.top = "0px";
            A.BackingCanvas.ctx = A.BackingCanvas.getContext('2d');

            A.FocusCanvas.onmousemove=mousemoveOnMap;
            A.FocusCanvas.onmouseout=removeAdornments;
            A.FocusCanvas.onclick=onFocusClicked;

            A.FocusCanvas.style.position = "absolute";
            A.FocusCanvas.style.left = "0px";
            A.FocusCanvas.style.top = "0px";
            A.FocusCanvas.ctx = A.FocusCanvas.getContext('2d');

            A.DetailDiv.innerHTML="Some Text";
            A.DetailDiv.style.backgroundColor = "rgba(0,0,0,0.6)";
            A.DetailDiv.style.position = "absolute";
            A.DetailDiv.style.left = "0px";
            A.DetailDiv.style.top = "0px";

            A.DetailDiv.style.display = "none";
            A.DetailDiv.className = "detaildiv";

            // Hotspot canvas and context do not need to be attached.
            A.Hotspots.canvas = document.createElement('canvas');


            resizeDivs();

        }

        function updateImages(){
            if((A.RootObject.content.length == 1) &&
               (A.RootObject.content[0].type == "Image" )){
                var obj = A.RootObject.content[0];
                if( obj.file ){
                    obj.img.src = obj.file;
                }
                if( obj.hot && obj.hot.file ){
                    obj.hot.img.src = obj.hot.file;
                }
            }
            onChart();
        }

        function addImagesToDom(){
            var A=Annotator;
            //Status.isAppReady = true;
            A.Backing = {};
            //updateImages();
        }

        function setATitle( caption, page, fromWiki ){
            var atitle= document.getElementById("atitle");
            var str = "<em>"+caption+"</em>";
            if( page )
                str+=" &nbsp; [ <a href='https://wiki.audacityteam.org/w/index.php?title=Toolbox/"+page+"&action=edit'>edit</a> ]";
            atitle.innerHTML = sanitiseHtml( str );
        }

        // finds field value to first ; or </pre>
        function fieldValue( field, line ){
            var value = line.split( field+"=" )[1] || "";
            value = value.split( "</pre>")[0];
            if( value.indexOf('\n')==-1 )
                value = value.split( ";")[0];

            return value;
        }

        function setHover( type, location ){
            var A=Annotator;
            var h = A.Hotspots.Current.Hover || {};
            h.Action = type;
            h.Name = location;
            A.Hotspots.Current.Hover=h;
        }

        function setClick( type, location ){
            var A=Annotator;
            var h = A.Hotspots.Current.Click || {};
            h.Action = type;
            h.Name = location;
            A.Hotspots.Current.Click=h;
        }

        function fixHyperlinks( text ){
            text = text.split( "[http" );
            var result=text[0];
            text[0]="";
            text.forEach( function( item ){
                if( item ){
                    item = item.replace(" ", "'>");
                    item = item.replace("]", "</a>");
                    result += "<a href='http" + item;
                }

            });
            return result;
        }

        function sanitiseHtml( html ){
            html = fixHyperlinks( html );
            // Whitelist all relevant tags.
            return html;
        }



        function drawCells( obj, data ){
            visit( drawThing, obj, data );
        }

        function drawContainer(obj,d){
            //console.log( "draw container - "+obj.type);
            var n = obj.content.length;
            for( var i=0;i<n;i++ )
                drawCells(obj.content[i],d );
        }

        drawThing = {
            "default":function(obj,d){
                //console.log( "draw (default) - "+obj.type);
            },
            "VStack":drawContainer,
            "HStack":drawContainer,
            "Overlay":drawContainer,

            "Chart":function(obj,d){
                //console.log( "draw - "+obj.type);
                var l = obj.layout;
                drawChart3(l.x0, l.y0, l.xw, l.yh, obj);
            },
            "PieChart":function(obj,d){
                //console.log( "draw - "+obj.type);
                var l = obj.layout;
                drawPieChart(l.x0, l.y0, l.xw, l.yh, obj);
            },
            "Image":function(obj,d){
                //console.log( "draw - "+obj.type);
                var l = obj.layout;
                drawImage(l.x0, l.y0, l.xw, l.yh, obj);
            },
            "Rectangle":function(obj,d){
                //console.log( "draw - "+obj.type);
                var l = obj.layout;
                drawRectangle(l.x0, l.y0, l.xw, l.yh, obj);
            },
            "Circle":function(obj,d){
                //console.log( "draw - "+obj.type);
                var l = obj.layout;
                drawCircle(l.x0, l.y0, l.xw, l.yh, obj);
            }
        };


        function sizeCells( obj, data ){
            visit( sizeThing, obj, data );
            //console.log( obj.sizing);
        }

        function sizeCell( obj, d, proportion ){
            //console.log( "size cell - "+obj.type);
            obj.sizing = {};
            obj.sizing.min = 0;
            obj.sizing.wants = (proportion===undefined) ? 1.0 : proportion;
            obj.sizing.cumulativeWants=0.0;
            if( d.hasOwnProperty( "sizeAs" )){
                obj.sizing.wants = d.sizeAs;
                delete d.sizeAs;
            }
        }

        function sizeContainer(obj,d){
            //console.log( "size container - "+obj.type);
            var n = 0;
            if(obj.content && Array.isArray(obj.content))
                n=obj.content.length;
            sizeCell( obj,d );
            for( var i=0;i<n;i++ ){
                var o2 = obj.content[i];
                sizeCells(o2, d);
                obj.sizing.min += o2.sizing.min;
                obj.sizing.cumulativeWants += o2.sizing.wants;
            }
        }

        function sizeContainer2(obj,d){
            sizeContainer(obj, d);
        }


        sizeThing = {
            "default":sizeContainer,
            //"VStack":sizeContainer,
            //"HStack":sizeContainer,
            //"Overlay":sizeContainer,

            // SizeAs gives this size to the next object.
            // The size is normally 1, so 2 will increase
            // the size, 0.5 will decrease the size.
            "SizeAs":function(obj,d){
                sizeCell( obj, d, 0.0);
                d.sizeAs = obj.value;
            },
            // Spacer makes some open space
            "Spacer":function(obj,d){
                sizeCell( obj, d, obj.value);
            },
            //"Chart":sizeContainer,
            //"PieChart":sizeCell,
            //"Image":sizeContainer2,
            //"Rectangle":sizeCell,
            //"Circle":sizeCell
        };




        function layoutCell( x0, y0, xw, yh, obj, d ){
            obj.layout = { "x0":x0,"y0":y0, "xw":xw, "yh":yh};
            //console.log( obj.layout );
        }

        function layoutCells( x0, y0, xw, yh, obj, d ){
            layoutCell( x0, y0, xw, yh, obj, d );
            visit( layoutThing, obj, d );
        }

        function layoutMargined( obj, d ){
            //console.log( "layout - "+obj.type);
            var m = d.margins;
            var l = obj.layout;
            layoutCell(l.x0+m, l.y0+m, l.xw-2*m, l.yh-2*m, obj,d);
        }

        function layoutUnmargined( obj, d ){
            //console.log( "layout - "+obj.type);
            var m = 0;
            var l = obj.layout;
            layoutCell(l.x0+m, l.y0+m, l.xw-2*m, l.yh-2*m, obj,d);
        }

        layoutThing = {
            "default":layoutUnmargined,
            "VStack":function(obj,d){
                //console.log( "layout - "+obj.type);
                var n = obj.content.length;
                var l = obj.layout;
                var k = obj.sizing.cumulativeWants;
                //console.log( "n: "+n+", k:"+k);
                var wantsSoFar = 0.0;
                for( var i=0;i<n;i++ ){
                    var want = obj.content[i].sizing.wants;
                    layoutCells(l.x0, l.y0 + (wantsSoFar / k) * l.yh, l.xw, l.yh * (want/k), obj.content[i], d);
                    wantsSoFar += want;
                }
            },
            "HStack":function(obj,d){
                //console.log( "layout - "+obj.type);
                var n = obj.content.length;
                var l = obj.layout;
                var k = obj.sizing.cumulativeWants;
                //console.log( "n: "+n+", k:"+k);
                var wantsSoFar = 0.0;
                for( var i=0;i<n;i++ ){
                    var want = obj.content[i].sizing.wants;
                    layoutCells(l.x0 + (wantsSoFar / k) * l.xw, l.y0, l.xw * (want/k), l.yh, obj.content[i], d);
                    wantsSoFar += want;
                }
            },
            // Superimposed elements, all the same size.
            "Overlay":function(obj,d){
                //console.log( "layout - "+obj.type);
                var n = obj.content.length;
                var l = obj.layout;
                for( var i=0;i<n;i++ ){
                    layoutCells(l.x0,l.y0, l.xw, l.yh, obj.content[i], d);
                }
            },
            "Chart": layoutMargined,
            //"PieChart":layoutMargined,
            "Image": layoutUnmargined,
            "Rectangle":function(obj,d){
                //console.log( "layout - "+obj.type);
                var m = d.margins;
                var l = obj.layout;
                layoutCell(l.x0+m, l.y0+m, l.xw-2*m, l.yh-2*m, obj,d);
            },
            "Circle":function(obj,d){
                //console.log( "layout - "+obj.type);
                var m = d.margins;
                var l = obj.layout;
                layoutCell(l.x0+m, l.y0+m, l.xw-2*m, l.yh-2*m, obj,d);
            }

        };







        // converts user friendly format into more
        // verbose but more uniform format,
        // with content and type fields.


        // @how has a function for each type of object
        // @what is an object to visit
        // @data carries extra information into the function
        function visit( how, what, data ){
            if( how[ what.type ] ){
                how[ what.type].call( how, what, data );}
            else
                how.default.call( how, what, data );
        }

        function convertJsonStructure( indent, layout )
        {
            var key;
            for( key in layout ){
                if( !layout.hasOwnProperty( key ) )
                        continue;
                var ch = key.substr( 0, 1);
                if( ch != ch.toUpperCase() )
                        continue;

                // If an array, then there are more objects
                // to explore.
                if( Array.isArray( layout[key]) ){
                    layout.content = layout[key];
                }
                else {
                    // otherwise there are no contents.
                    layout.content = [];
                    layout.value = layout[key];
                }
                layout.type = key;
                delete layout[ key ];

                //console.log( indent+key );
                break;
            }
            if( (!layout.id) && layout.value && (typeof layout.value) == "string" ){
                layout.id = layout.value;
            }
            if( layout.id ){
                layout.id = layout.id.substr(0, 10);
                A.RootObject.objectDict[layout.id] = layout;
                A.RootObject.objectList.push( layout );
            }
            if( layout.content && Array.isArray( layout.content)){
                for( var i = 0; i < layout.content.length; i++ ){
                    //console.log( indent+"Arg: "+i);
                    convertJsonStructure( indent + "   ",layout.content[i] );
                }
            }
        }

        function getObjectByName(name){
            if( !name )
                    return 0;
            if( !A.RootObject.objectDict )
                    return 0;
            var shortName = name.substr(0, 10);
            return A.RootObject.objectDict[ shortName ];
        }

        function isDefined( x ){
            var undef;
            return x !== undef;
        }

        function startChart(){
            A.Porthole.width = 700;
            A.Porthole.height = 200;

            A.RootObject.type = 'VStack';
            A.RootObject.content = [];
            A.RootObject.itemIndex = 0;
            A.RootObject.objectDict = {};
            A.RootObject.objectList = [];
        }

        function loadNewDetails( specFileData ){
            var A=Annotator;
            var lines = specFileData.split("<pre>");
            setATitle("Caption was missing");
            startChart();
            for(i=0;i<lines.length;i++)
            {
                var item=lines[i];
                var detail = item.split("TIP=</pre>")[1];
                var file  = item.split( "[[File:")[1] || "";
                file = file.split( "]]")[0] || "";
                file = "./images/"+file;

                var spec = item.split( "[[")[1] || "";
                spec = spec.split( "]]")[0] || spec;
                spec = spec.split( "|")[0] || spec;

                if( item.startsWith("ZONE:RGBA=(")){
                    var index = fieldValue( "RGBA", item );
                    index=index.split(" ").join("");
                    index=index.replace("(","[");
                    index=index.replace(")","]");
                    console.log("color:"+index);
                    A.AddHot( index );
                }
                if( item.startsWith("NEXTZONE:")){
                    if( A.Hotspots.ColourZones ){
                        var n = A.Hotspots.ColourZoneIx;
                        var c= A.Hotspots.ColourZones[n];
                        A.Hotspots.ColourZoneIx = (n+1)% A.Hotspots.ColourZones.length;
                        c='['+c[0]+','+c[1]+','+c[2]+','+c[3]+']';
                        console.log( "next-color:"+ c );
                        A.AddHot( c );
                    }
                }
                if( item.startsWith("ZONE:LABEL=") ||
                    item.startsWith("BUTTON:LABEL=")
                ){
                    var label = fieldValue( "LABEL",item );
                    console.log("label:"+label);
                    A.AddButton( label );
                    if( !detail )
                        detail =" ";
                }
                if( item.startsWith("HOVER LOAD IMAGE")){
                    console.log("hover-load-image:"+file);
                    setHover( "Image", file );
                }
                if( item.startsWith("HOVER LOAD SPEC")){
                    file = ("X"+spec).split("Toolbox/")[1] ||
                        fieldValue( "SPEC",item );
                    console.log("hover-load-spec:"+file);
                    setHover( "Spec", file );
                }
                if( item.startsWith("CLICK LOAD IMAGE")){
                    console.log("click-load-image:"+file);
                    setClick( "Image", file );
                }
                if( item.startsWith("CLICK LOAD SPEC")){
                    file = ("X"+spec).split("Toolbox/")[1] ||
                            fieldValue( "SPEC",item );
                    console.log("click-load-spec:"+file);
                    setClick( "Spec", file );
                }
                if( item.startsWith("CLICK GOTO")){
                    file = item.split("GOTO=</pre>")[1]||"";
                    // extract a wiki hyperlink.
                    file = ("X"+file).split("[")[1] || "";
                    file = file.split(" ")[0] || file.split("]")[0] || "";

                    console.log("click-goto:"+file);
                    setClick( "Goto", file );
                }
                if( item.startsWith("IMAGE5")){
                    console.log("image:"+file);
                    A.Image.imageSrc = file;
                }
                if( item.startsWith("DISTORTION")){
                    console.log("distortion:");
                    A.Distortion.Map = "spherical";

                    var obj = A.RootObject.lastImage;
                    if( !obj )
                        continue;
                    obj.spherical = true;

                }
//                if( item.startsWith("HOTSPOTS")){
//                    console.log("hotspots:"+file);
//                    A.Hotspots.imageSrc = file;
//                }
                if( item.startsWith("COLOURSET=")){
                    var data = fieldValue( "OURSET",item );
                    console.log("colour-data:"+data);
                    var obj = JSON.parse( data );
                    //console.log(obj);
                    A.Hotspots.ColourZones = obj;
                    A.Hotspots.ColourZoneIx=0;
                }
                if( item.startsWith("ZONECOLOURS=")){
                    var data = fieldValue( "COLOURS",item );
                    console.log("colour-data:"+data);
                    var obj = JSON.parse( data );
                    console.log(obj);
                    A.Hotspots.ColourZones = obj;
                    A.Hotspots.ColourZoneIx=0;

                }
                if( item.startsWith("FLOWCHART:") ||
                        item.startsWith("ADD:")
                ){
                    var data = fieldValue( "DATA",item );
                    console.log("flow-data:"+data);
                    var obj = JSON.parse( data );
                    //console.log(obj);

                    convertJsonStructure( "",obj );
                    A.RootObject.content.push( obj );
                    A.Porthole.height += 200;
                    //console.log(obj);
                }
                if( item.startsWith("CHART")){
                    var data = fieldValue( "DATA",item );
                    console.log("chart-data:"+data);
                    var obj = JSON.parse( data );
                    convertJsonStructure( "",obj );
                    obj.content=[];
                    obj.type = "Chart";

                    A.RootObject.content.push( obj );
                    A.Porthole.height += 200;
                }
                if( item.startsWith("IMAGE")){
                    console.log("image:"+file);
                    var obj=getObjectByName(fieldValue( "NAME",item ));
                    if( obj ){
                        obj.resize = false;
                    } else {
                        obj = {};
                        obj.Image = file;
                        convertJsonStructure("", obj);
                        obj.resize = A.RootObject.content.length ==0;
                        A.RootObject.content.push( obj );
                    }
                    A.RootObject.lastImage = obj;

                    obj.status = "asked";
                    obj.file = file;
                    obj.content = [];
                    obj.spherical = false;
                    obj.img = document.createElement( "img");
                    obj.img.onload = (function(){
                        var obj1 = obj;
                        return function(){
                            obj1.status="arrived";
                            console.log( obj1.file+" image arrived");
                            //alert("Loaded image " + obj1.file);
                            if( obj1.resize )
                                resizeForImage(obj1.img);
                            else if( Status.isAppReady )
                                onChart();
                        }
                    })();
                    obj.img.onerror = (function(){
                        var obj1 = obj;
                        return function(){
                            obj1.status="failed";
                            alert("Failed to load image " + obj1.file);
                        }
                    })();
                    obj.img.src = file;

                }
                if( item.startsWith("HOTSPOTS")){
                    console.log("hotspots:"+file);
                    var obj = A.RootObject.lastImage;
                    if( !obj )
                            continue;

                    obj.hot={};
                    obj.hot.status = "asked";
                    obj.hot.file = file;
                    obj.hot.img = document.createElement( "img");
                    obj.hot.img.onload = (function(){
                        var obj1 = obj;
                        return function(){
                            obj1.hot.status="arrived";
                            console.log( obj1.file+" HS arrived");
                            if( Status.isAppReady )
                                drawCells(A.RootObject, {});
                        }
                    })();
                    obj.hot.img.onerror = (function(){
                        var obj1 = obj;
                        return function(){
                            obj1.status="failed";
                            alert("Failed to load hotspots " + obj1.hot.file);
                        }
                    })();
                    obj.hot.img.src = file;
                }

                if( item.startsWith("NEXTOBJECT:") ){
                    if( !isDefined( A.RootObject.objectList ))
                            continue;
                    var n = A.RootObject.itemIndex++;
                    obj = A.RootObject.objectList[n];
                    if( !isDefined( obj ) )
                            continue;

                    var data;
                    data = fieldValue("COLOUR",item);
                    if( data )
                        obj.colour=data;
                    data = fieldValue("BCOLOUR",item);
                    if( data )
                        obj.bcolour=data;
                    data = fieldValue("CORNER_RADIUS",item);
                    if( data && (!isNaN(Number(data))))
                        obj.corner_radius = Number(data);
                    if( detail ){
                        // Note that Chrome and other
                        // browsers may not preserve the
                        // alpha exactly.
                        var c="["+(n+2)+",21,0,255]";
                        obj.hotspotColour = rgbOfColourTuple(c);
                        A.AddHot(c);
                    }
                }

                if( item.startsWith("ARROWS:")){
                    var data = fieldValue( "DATA",item );
                    console.log("arrow-data:"+data);
                    var obj = JSON.parse( data );
                    //console.log(obj);
                    A.RootObject.arrows = obj;
                }

                if( item.startsWith("CREDITS")){
                    A.caption = fieldValue( "CAPTION",item );
                    console.log("caption:"+ A.caption);
                    setATitle(A.caption, A.page, A.fromWiki );
                    // Reserve a colour for the info button.
                    A.AddInfo();
                }
                if( detail ){
                    detail = sanitiseHtml(detail);
                    console.log(" <<<" + detail + ">>>");
                    A.AddDetail(detail);
                }
            }
            Status.time = 0;
            updateImages();
        }

         function handleNewData( data ){
            var spec = document.getElementById("spec");
            // for debugging...
            //spec.innerHTML = data.split("<pre>START</pre>")[1];
            resetHotspots();
            loadNewDetails( data );
        }

         /**
         * Loads one source file into an item in an array.
         * @param data
         * @param action
         * @param url
         * @param data
         * @param action
         * @param url
         */
        function fileActionLoader(data, action, url ){
            var txtFile = new XMLHttpRequest();
            // CDNs and Varnish should give us the very latest.
            txtFile.onreadystatechange = function(){
                if( this.readyState === 4 && this.status == 200 ){
                    // data.push({ action: action, value: this.responseText});
                    handleNewData( this.responseText);
                }
            };

            txtFile.open("GET", url , true);
            //txtFile.setRequestHeader( "Cache-Control", "s-maxage=0" );
            txtFile.send();
        }


        function requestSpec( source, fromwiki ){
            var A=Annotator;
            A.SpecName = source;

            if( fromwiki == 'no'){
                fileActionLoader("","","./raw/raw_spec_"+source+".txt");
            } else {
                var date = new Date();
                var nMillis = date.getTime();
                // action=raw to get unprocessed file from wiki.
                // time=nMillis to avoid issues with cached content.
                fileActionLoader( "","","https://wiki.audacityteam.org/wiki/Toolbox/"+source+"?action=raw&time=" +
                        nMillis);
            }



        }

        function loadDiagram( source, fromwiki ){
            var spec = document.getElementById("spec");
            spec.innerHTML = "";
            requestSpec( source, fromwiki );
        }

        function removeFrame(){
            var doc = document.getElementById("body");
            doc.innerHTML = '<div id="content_here" style="text-align:center;"></div><div id="atitle" style="text-align:center;"><em>No Hotspot Zones Loaded (Yet)</em></div><div id="spec" style="margin-left:10px"></div>';
        }

        function getArg( line, arg ){
            line="&"+line.split('?')[1]||"";
            line=line.split( '&'+arg+'=' )[1]||"";
            line=(line+'&').split('&')[0];
            return line;
        }

        function isFromServer(){
            var str = window.location.href;
            return (str.indexOf( 'localhost' ) != -1)?
                    "no" :"yes";
        }

        window.onload = function(){

            var query = window.location.href;
            A.page = getArg( query, 'page' ) || "The_AU19_Crowd";
// Can't use the following on IE 11.
//          var url = new URL(query);
//          var page = url.searchParams.get("page") || "The_AU19_Crowd";
            var frame = getArg( query, 'frame' ) || "yes";

            A.fromWiki = isFromServer();
            A.fromWiki = getArg( query, 'fromwiki' ) || A.fromWiki;
            if( frame == "no" )
               removeFrame();

            createDomElements();
            addImagesToDom();

            console.log(A.page);
            loadDiagram(A.page, A.fromWiki);
            // Timer is for animation such as rotating earth.
            setInterval(timerCallback, 30);
            //requestSpec();
        }

    </script>
</head>
<body id="body" style="color:white;background-image:url(images/header-home-bg.jpg);margin:0px;background-attachment:fixed;">
<div style="width:100%; text-align:center;background:#1d2134;height:5em;margin: 0px;">
    <h1 style="margin:0px;padding-top:0.65em;padding-bottom:0.9em;"><em>Audacity Tool Kit</em>: Demo Page</h1>
    <div style="width:100%; text-align:center;background:#303b70;position:relative;height:1.8em;top:-0.6em;box-shadow: inset 0 0px 4px 0px #000080, 0 -2px 7px -2px #618ef4;"></div>
</div>
<div style="width:100%;position:relative;top:-0.50em;left:0;display:inline-block;margin:0 auto;height:3em;">
    <div class='pos-resetter'>
        <h2 id="click-tip" style="color:#bfbfbf;display:block;position:relative;top:-0.55em;transition:opacity 4s;opacity:1;"><em>Version from 27-Nov-2019</em></h2>
    </div>
    <div class='pos-resetter'>
        <div style="display:inline-block;">
            <div class='linky' id="manual-url-holder">
                Manual's URL, here</div> &nbsp;
            <div class='linky' id="wit-url-holder">
                WIT's URL, here</div> &nbsp;
            <div class='linky' id="doxy-url-holder">
                Doxygen's URL, here</div>
        </div>
    </div>
</div>
<a  href="https://www.audacityteam.org">
    <div id="logoback" >
        <img id='logo' src="images/audacity-logo.png">
    </div>
</a>
<div style="height:1.9em;"></div>

<div id="content_here" style="text-align:center;">
</div>

<div id="atitle" style="text-align:center;">
    <em>No Hotspot Zones Loaded (Yet)</em>
</div>

<div style="margin-left:10px;color:#c2c2c2">
    <div id="message"></div>
    <div id="message2"></div>
</div>
<div style="margin-left:50px">
<p>Demos from the Audacity Tool Kit.
<p> Follow links below to see each of the examples.
</div>
<div style="margin-left:10px">

    These examples have their specification in an editable wiki page.  Some are 'works in progress' (wip).
    <ul>
    <li><a href="./demos.htm?page=The_AU19_Crowd">The Audacity 2019 Unconference</a> - an annotated image people-identifier - <a href="https://wiki.audacityteam.org/wiki/Toolbox/The_AU19_Crowd">wiki spec</a>, <a href="./demos.htm?page=The_AU19_Crowd&fromwiki=no">no wiki</a><br>
    <li><a href="./demos.htm?page=Window_Size"> Spectrogram
    Window-Size Explanation</a> - an interactive diagram about a spectrogram - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Window_Size">wiki spec</a>, <a href="./demos.htm?page=Window_Size&fromwiki=no"> no wiki</a>

    <li><a href="./demos.htm?page=Hotspots"> More about the Focus-Detail tool</a> - shows the coloured hotspots image - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Hotspots">wiki spec</a>, <a href="./demos.htm?page=Hotspots&fromwiki=no">no wiki</a>
        <li><a href="./demos.htm?page=The_Ear"> The Ear</a>- <em>(wip)</em> using images from Blausen Medical (hotspots in subsidiary images to do &amp; mystery-meat fix) This is three linked image-mapped diagrams, the ear as a whole, and middle and inner ear - <a href="https://wiki.audacityteam.org/wiki/Toolbox/The_Ear">wiki spec</a>, <a href="./demos.htm?page=The_Ear&fromwiki=no">no wiki</a>
        <li><a href="./demos.htm?page=Bug_Counts"> Bug Counts</a>- <em>(wip)</em> Audacity bug tracking - driven from data in wiki (scales, key and hotspots to do) - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Bug_Counts">wiki spec</a>, <a href="./demos.htm?page=Bug_Counts&fromwiki=no">no wiki</a>
        <li><a href="./demos.htm?page=Köppen_Climate_Classification"> Köppen Climate Classification</a> - <em>(wip)</em> A demo where the image is already colour coded - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Köppen_Climate_Classification">wiki spec</a>, <a href="./demos.htm?page=Köppen_Climate_Classification&fromwiki=no">no wiki</a></li></ul>



        These examples have their specification as an ordinary text file.  They could have an editable wiki page if we wanted (by pasting the text file into wiki).
<ul>
        <li><a href="./demos.htm?page=The_Situation_Room&fromwiki=no">The Situation Room</a> - more annotation of an image.  This is a featured image from Wikipedia<br>
        <li><a href="./demos.htm?page=Lunar_Sites&fromwiki=no"> Lunar Sites</a>- <em>(Experimental)</em> A demo where the image is wrapped onto a sphere (no hotspots yet, distorted)
        <li><a href="./demos.htm?page=Köppen_Globe&fromwiki=no"> Climate Zone as Globe</a>- <em>(Experimental)</em> Moon trick done for Köppen Image (no hotpsots yet, distorted)
    <li><a href="./demos.htm?page=Ocean_Currents&fromwiki=no"> Ocean Currents as Globe</a>- <em>(Experimental)</em> Moon trick done for Ocean Currents Image (no hotpsots yet, distorted)
    <li><a href="./demos.htm?page=Flow_Graph"> Flow Graph</a>- <em>(Experimental)</em> Flowchart of Making the Manual - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Flow_Graph">wiki spec</a>
    <li><a href="./demos.htm?page=Subdivision"> Subdivision</a>- <em>(Experimental)</em> Methods for subdividing a diagram - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Subdivision">wiki spec</a>
    <li><a href="./demos.htm?page=Graphing"> Graphing</a>- <em>(Experimental)</em> Various graphs - <a href="https://wiki.audacityteam.org/wiki/Toolbox/Graphing">wiki spec</a>
</ul></ul>


<!---
    <button onclick=loadDiagram('The_Ear')>Load</button> Ear Explanation<br>
-->
</div>
<div id="spec" style="margin-left:10px"></div>
</body>
</html>